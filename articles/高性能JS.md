# 高性能JS

##加载与执行

无论当前 JavaScript 代码是内嵌还是在外链文件中，页面的下载和渲染都必须停下来等待脚本执行完成。JavaScript 执行过程耗时越久，浏览器等待响应用户输入的时间就越长。浏览器在下载和执行脚本时出现阻塞的原因在于，脚本可能会改变页面或 JavaScript 的命名空间，它们对后面页面内容造成影响。

例如

```html
<html>
<head>
    <title>Source Example</title>
</head>
<body>
    <p>
    <script type="text/javascript">
        document.write("Today is " + (new Date()).toDateString());
    </script>
    </p>
</body>
</html>
```

当浏览器遇到`<script>`标签时，当前 HTML 页面无从获知JavaScript 是否会向`<p>`标签添加内容，或引入其他元素，或甚至移除该标签。因此，这时浏览器会停止处理页面，先执行 JavaScript代码，然后再继续解析和渲染页面。同样的情况也发生在使用src 属性加载JavaScript的过程中，浏览器必须先花时间下载外链文件中的代码，然后解析并执行它。在这个过程中，页面渲染和用户交互完全被阻塞了。

### 脚本位置

`<script>` 标签可以放在 HTML 文档的`<head>`或`<body>`中，并允许出现多次。但是如果放在head中了，浏览器解析到script标签时，会停止解析其后内容，而优先下载脚本文件，并执行其中的代码。这意味着其后的 styles.css 样式文件和`<body>`标签都无法被加载，由于`<body>`标签无法被加载，那么页面自然就无法渲染了。因此在该 JavaScript 代码完全执行完之前，页面都是一片空白。（如果脚本要操作尚未解析完的DOM将会出错）

![](https://www.ibm.com/developerworks/cn/web/1308_caiys_jsload/image003.jpg)

JS文件的加载与执行阻塞了其他文件的下载

最好实践：尽管现在JS文件可以并行下载，互不影响。但是JS的下载仍然阻塞其他资源的下载（CSS），推荐将脚本放在body标签底部。

组织文件：将多个文件合并成一个，使用CDN网络分发

无阻塞脚本，延迟的脚本：通过defer属性延迟执行<script type="text/javascript" src="script1.js" defer> defer属性指明本元素所含有的脚本不会修改DOM

``</script>`带有 `defer` 属性的`<script>`标签可以放置在文档的任何位置。对应的 JavaScript 文件将在页面解析到`<script>`标签时开始下载，但不会执行，直到 DOM 加载完成，即`onload`事件**触发前**才会被执行。当一个带有 `defer` 属性的 JavaScript 文件下载时，它不会阻塞浏览器的其他进程，因此这类文件可以与其他资源文件一起并行下载。任何带有 `defer` 属性的`<script>`元素在 DOM 完成加载之前都不会被执行，无论内嵌或者是外链脚本都是如此

动态脚本元素：用DOM API创建脚本元素。此文件当元素添加到页面之后立刻开始下载。此技术的重点在于：无论在何处启动下载，文件的下载和运行都不会阻塞其他页面处理过程。您甚至可以将这些代码放在`<head>`部分而不会对其余部分的页面代码造成影响（除了用于下载文件的 HTTP 连接）。  当文件使用动态脚本节点下载时，返回的代码通常立即执行。`<script>`节点接收完成之后发出一个 `onload` 事件。您可以监听这一事件，以得到脚本准备好的通知

AJAX加载脚本：这种方法的主要优点是，您可以下载不立即执行的 JavaScript 代码。由于代码返回在`<script>`标签之外（换句话说不受`<script>`标签约束），它下载后不会自动执行，这使得您可以推迟执行，直到一切都准备好了。另一个优点是，同样的代码在所有现代浏览器中都不会引发异常。  限制：跨域资源请求

减少 JavaScript 对性能的影响有以下几种方法：

- 将所有的`<script>`标签放到页面底部，也就是`</body>`闭合标签之前，这能确保在脚本执行前页面已经完成了渲染。
- 尽可能地合并脚本。页面中的`<script>`标签越少，加载也就越快，响应也越迅速。无论是外链脚本还是内嵌脚本都是如此。
- 采用无阻塞下载 JavaScript 脚本的方法：
  - 使用`<script>`标签的 defer 属性（仅适用于 IE 和 Firefox 3.5 以上版本）；
  - 使用动态创建的`<script>`元素来下载并执行代码；
  - 使用 XHR 对象下载 JavaScript 代码并注入页面中。



## 数据存储

**1.JavaScript中四种基本数据存取位置：字面量，本地变量，数组元素，对象成员。**
一般来说：**[字面量,局部变量]运行速度>[数组,对象成员]**
**2.内部属性包含了一个函数被创建的作用域中对象的集合。这个集合被称为作用域链。**
**3.执行函数->创建执行环境->创建活动对象(即函数运行时变量对象)。**
所以多次调用同一个函数会导致创建多个执行环境。
**4.函数执行过程**
每遇到一个变量都会经历一次标识符解析过程，从哪里获取或存储数据。该过程搜索执行环境的作用域链。正是这种搜索过程影响了性能。
**5.标识符解析的性能** 
全局变量总是存在于执行环境作用域的**最末端**。局部变量是第一顺位解析。
经验法则：如果某个跨作用域的值在函数中被引用一次以上，那么就把他存储到局部变量中。
**6.改变作用域链**
一般来说，一个执行环境的作用域链不会改变的。

**<1>with可以临时改变作用域链**

width用来给对象的所有属性创建一个变量当代码执行到with时，**执行环境的作用域链被临时改变了**。一个新的变量对象呗创建，它包含了参数指定对象的所有属性。**这个对象呗推入作用域链的首位**，所以这时候所有的局部变量处于的哥第二个作用域链对象中，因此访问代价更高了。

**<2>try-catch**

try语句发生错误的时候，执行过程会自动跳转到catch中。**然后把异常对象推入一个变量对象并置于作用域的首位。**

**注意：**一旦catch子语句执行完毕，作用域链就会返回到之前的状态。

**7.闭包引发的性能问题**
闭包是JavaScript最强大的特性之一。
由于闭包包含了执行了与环境作用域链相同对象的引用，函数的活动对象不会被销毁，造成更多的内存开销。
**关注的性能点**：频繁访问跨作用域的标识符时，每次访问都会带来性能损失。

**8.内存泄露**
内存泄露是指一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束。在C++中，因为是手动管理内存，内存泄露是经常出现的事情。而现在流行的C#和Java等语言采用了自动垃圾回收方法管理内存，正常使用的情况下几乎不会发生内存泄露。浏览器中也是采用自动垃圾回收方法管理内存，但由于浏览器垃圾回收方法有bug，会产生内存泄露。
**内存泄露的几种情况**

- 循环引用
- Javascript闭包
- DOM插入顺序

一个DOM对象被一个Javascript对象引用，与此同时又引用同一个或其它的Javascript对象，这个DOM对象可能会引发内存泄漏。这个DOM对象的引用将不会在脚本停止的时候被垃圾回收器回收。要想破坏循环引用，引用DOM元素的对象或DOM对象的引用需要被赋值为null。

**具体的就深入讨论了，这里的总结**

- JS的内存泄露，无怪乎就是从DOM中remove了元素，但是依然有变量或者对象引用了该DOM对象。然后内存中无法删除。使得浏览器的内存占用居高不下。这种内存占用，随着浏览器的刷新，会自动释放。
- 而另外一种情况，就是循环引用，一个DOM对象和JS对象之间互相引用，这样造成的情况更严重一些，即使刷新，内存也不会减少。这就是严格意义上说的内存泄露了。
- 对象成员的嵌套也会开销系统资源。`location.href`永远会比`window.location.href`快。
- 访问直接量和局部变量的速度最快，相反，访问数组元素和对象成员相对较慢。
- 由于局部变量存在于作用域链的起始位置，因此访问局部变量比访问跨作用域变量更快。变量在作用域链中的位置越深，访问所需时间就越长。由于全局变量总处在作用域链的最末端，因此访问速度也是最慢的。
- 避免使用`with`语句，因为它会改变运行期上下文作用域链。同样，`try-catch`语句中的`catch`子句也有同样的影响，因此要小心使用。
- 嵌套的对象成员会明显影响性能，尽量少用
- 属性或方法在原型链中的位置越深，访问它的速度也越慢。
- 局部通常来说，你可以通过把常用的对象成员、数组元素、跨域变量保存在变量中来改善javascript的性能，因为局部变量访问速度最快。

## DOM编程

减少DOM元素访问，将运算方面留给JS方面执行

- 最小化`DOM`访问次数，尽可能在javascript端处理
- 如果需要多次访问某个`DOM`节点，请使用局部变量存储它的引用
- 小心处理HTML集合，因为它实时联系着底层文档。把集合的长度缓存到一个变量中，并在迭代中使用它。如果需要经常操作集合，建议把它拷贝到一个数组中。
- 遍历一个集合时，第一把集合存储局部变量，缓存长度，用局部变量替代多次访问的元素
- 使用更好的API，chidren childElement nextElementSibling等等，不用node child之类的
- 如果可能的话，使用速度更快的API，比如`querySelectorAll()`和`firstElementChild()`。 这些比老API性能更好，功能更完善
- 要留意重绘和重排；批量修改样式时，“离线”操作DOM树，使用缓存，并减少访问布局信息的次数。
- 动画中使用绝对定位，使用拖放代理
- 使用事件委托来减少事件处理器的数量

### 重绘与回流

浏览器下载完页面中的所有组件——html标记，js,css 图片之后，会生成两个内部数据结构：

- DOM树
- 渲染树

DOM树中的每一个需要显示的节点在渲染树中至少有一个对应的节点（隐藏的DOM元素在渲染树中没有对引的节点）。渲染树中的节点被定义为帧(frame)或者盒(box)，符合CSS盒子模型的定义,理解页面元素为一个具有内边距、外边距、边框、位置的盒子。一旦DOM和渲染树构建完成，浏览器就开始绘制(paint)。

当DOM的变化影响了元素的几何属性（宽或高），浏览器需要重新计算元素的几何属性，同样其他元素的几何属性和位置也会因此受到影响。浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。这个过程叫做**回流** 。完成回流后，浏览器会重新绘制受影响的部分到屏幕，该过程称为**重绘**。

当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘。

#### 回流何时发生？：

1. 添加或者删除可见的DOM元素；
2. 元素位置改变；
3. 元素尺寸改变——边距、填充、边框、宽度和高度
4. 内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变；
5. 页面渲染初始化；
6. 浏览器窗口尺寸改变——resize事件发生时；

```js
var s = document.body.style;
s.padding = "2px"; // 回流+重绘
s.border = "1px solid red"; // 再一次 回流+重绘
s.color = "blue"; // 再一次重绘
s.backgroundColor = "#ccc"; // 再一次 重绘
s.fontSize = "14px"; // 再一次 回流+重绘
// 添加node，再一次 回流+重绘
document.body.appendChild(document.createTextNode('abc!'));
```

回流比重绘的代价要更高，回流的花销跟render tree有多少节点需要重新构建有关系，假设你直接操作body，比如在body最前面插入1个元素，会导致整个render tree回流，这样代价当然会比较高，但如果是指body后面插入1个元素，则不会影响前面元素的回流。

#### 渲染树变化的排队与刷新(queuing and Flushing Render Tree Change)

由于重排产生计算消耗，大多数浏览器通过队列化修改并批量执行来优化重绘、回流过程。等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会flush队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。

但有时候我们写的一些代码可能会强制浏览器提前flush队列并要求计划任务立即执行，获取布局信息会导致队列刷新。比如以下方法：

1. offsetTop, offsetLeft, offsetWidth, offsetHeight
2. scrollTop/Left/Width/Height
3. clientTop/Left/Width/Height
4. width,height
5. getComputedStyle

以上属性方法都需要返回最新的布局信息，因此浏览器不得不处理渲染列队中的“待处理变化”并触发回流。当你请求上面的一些属性的时候，浏览器为了给你最精确的值，需要flush队列，因为队列中可能会有影响到这些值的操作。即使你获取元素的布局和样式信息跟最近发生或改变的布局信息无关，浏览器都会强行刷新渲染队列。

实践：在修改样式的过程中最好避免使用上面列出的属性

#### 最小化回流重绘

- 不要再布局信息改变时查询引起flush的属性，实在要访问就利用缓存

- 合并多次对DOM样式的修改，然后一次处理掉。或者改class

  ```js
  const el = document.querySelector('myDiv')
  el.style.borderLeft = '1px'
  el.style.borderRight = '2px'
  el.style.padding = '5px'
  //wrong,
  el.style.cssText = 'border-left:1px border-right:2px padding: 5px'//right

  //如果想保留原有样式，可如下
  el.style.cssText += '; border-left:1px;'
  ```

- 修改CSS的class名称`el.className = 'active'`

- 批量修改DOM
