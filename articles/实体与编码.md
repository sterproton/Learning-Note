# HTTP实体与编码

媒体对象通过HTTP传输，为了确保被正确传输，需要满足以下条件

- 正确识别：Content-Type 媒体格式 Content-Language说明语言
- 正确解包：Content-Length Content-Encoding
- 是最新的：Etag 、缓存控制 Last-Modified、Expires、Cache-Control
- 符合客户需要：Accept等
- 快速有效传输：范围请求、差异编码、数据压缩
- 完整到达：传输编码首部和Content-MD5

报文实体由报文首部和实体主体构成

---

• Content-Type
实体中所承载对象的类型。
• Content-Length
所传送实体主体的长度或大小。
• Content-Language
与所传送对象最相配的人类语言。
• Content-Encoding
对象数据所做的任意变换（比如，压缩）。
• Content-Location
一个备用位置，请求时可通过它获得对象。
• Content-Range
如果这是部分实体，这个首部说明它是整体的哪个部分。
• Content-MD5
实体主体内容的校验和。

• Last-Modified
所传输内容在服务器上创建或最后修改的日期时间。
• Expires
实体数据将要失效的日期时间。
• Allow
该资源所允许的各种请求方法，例如，GET 和HEAD。
• ETag
这份文档特定实例（参见15.7 节）的唯一验证码。ETag 首部没有正式定义为实
体首部，但它对许多涉及实体的操作来说，都是一个重要的首部。
• Cache-Control
指出应该如何缓存该文档。和ETag 首部类似，Cache-Control 首部也没有正
式定义为实体首部。

---

**Content-length** 除非使用分块编码，否则Content-length首部是带实体主体的报文必须使用的。使用Conent-length首部是为了能够检测服务器奔溃导致的报文结尾

报文截尾：早期HTTP使用关闭连接来划定报文的结束，但是如果没有Content-length的话客户端无法区分是报文结束时的的正常关闭连接还是报文传输过程中服务器奔溃导致的连接关闭。对于缓存服务器来说，如果收到截尾却无法正确识别，就可能存储不完整的内容，所以缓存代理服务器通常不会为没有显式设置content-length首部的HTTP主体做缓存

错误的Content-length比缺少Content-length糟糕，他可能导致服务器出现错误（无法解析、继续等待HTTP报文）

Content-Length首部对持久连接时必不可少的，因为可能由别的HTTP响应紧随其后，所以客户端可以通过content-length知道报文何时结束。有一种情况下，使用持久连接时可以没有Content-Length
首部，即采用分块编码（chunked encoding）时。在分块编码的情况下，数据是分为
一系列的块来发送的，每块都有大小说明。哪怕服务器在生成首部的时候不知道整
个实体的大小（通常是因为实体是动态生成的），仍然可以使用分块编码传输若干已
知大小的块。

---

内容编码

HTTP允许对实体主体进行编码使之更安全或者进行压缩以节省空间，进行内容编码后，Content-length长度为编码后的主体的长度（如果发送编码前的长度，就会发生错误）

---

实体摘要

为了检测实体的数据是否被篡改，发送方可以生成数据的检验和，这样接受方就可以通过检查校验和来

服务器使用Content-MD5 首部发送对实体主体运行MD5 算法的结果。为了验证报文的完整性，客户端必须先进行传输编码的解码，然后计算所得到的未进行传输编码的实体主体的MD5。举个例子吧，如果一份文档使用gzip 算法进行压缩，然后用分块编码发送，那么就对整个经gzip 压缩的主体进行MD5 计算。

除了检查报文的完整性之外，MD5 还可以当作散列表的关键字，用来快速定位文档
并消除不必要的重复内容存储。除了这些可能的用法，一般不常用到Content-MD5
首部。

#### 媒体类型

Content-Type 首部字段说明了实体主体的MIME 类型。6MIME 类型是标准化的名字，用以说明作为货物运载实体的基本媒体类型（比如：HTML 文件、MicrosoftWord 文档或是MPEG 视频等）。客户端应用程序使用MIME 类型来解释和处理其内容。

注意Content-type首部说明的是原始主体的媒体类型，如果实体经过内容编码，Content-type仍然说明之前的实体类型

Content-Type 首部还支持可选的参数来进一步说明内容的类型。charset（字符
集）参数就是个例子，它说明把实体中的比特转换为文本文件中的字符的方法：
Content-Type: text/html; charset=iso-8859-4

multipart媒体类型：分为表单提交的和多部分范围响应：multipart/byteranges

#### 内容编码

内容编码的过程如下所述。
（1） 网站服务器生成原始响应报文，其中有原始的Content-Type 和Content-
Length 首部。
（2） 内容编码服务器（也可能就是原始的服务器或下行的代理）创建编码后的报文。
编码后的报文有同样的Content-Type 但Content-Length 可能不同（比如
主体被压缩了）。内容编码服务器在编码后的报文中增加Content-Encoding
首部，这样接收的应用程序就可以进行解码了
（3） 接收程序得到编码后的报文，进行解码，获得原始报文。

内容编码的类型：gzip、compress、deflate、identity（没有对内容进行编码）

Accept-Encoding 字段包含用逗号分隔的支持编码的列表客户端可以给每种编码附带Q（质量）值参数来说明编码的优先级。Q 值的范围从0.0 到1.0，0.0 说明客户端不想接受所说明的编码，1.0 则表明最希望使用的编码。



#### 传输编码

传输编码也是作用在实体主体上的可你变换，使用它们是由于架构的原因同内容格式无关，是为了改变报文年数据在网络上的传输方式。

> 经过内容编码的报文，只是对报文的实体部分进行了编码。而对于经过传输编码的报文来说，编码作用在整个报文上，报文自身的结构发生了改变。

HTTP使用一下两个头部描述控制传输编码

• Transfer-Encoding
告知接收方为了可靠地传输报文，已经对其进行了何种编码。
• TE
用在请求首部中，告知服务器可以使用哪些传输编码扩展



如使用TE头部告诉服务器可以接受分块编码，并愿意接受附在分块编码结尾上的拖挂

```http
GET /new_products.html HTTP/1.1
Host: www.joes-hardware.com
User-Agent: Mozilla/4.61 [en] (WinNT; I)
TE: trailers, chunked
```

对它的响应中包含Transfer-Encoding 首部，用于告诉接收方已经用分块编码对
报文进行了传输编码：

```
HTTP/1.1 200 OK
Transfer-Encoding: chunked
Server: Apache/3.0
```

##### 分块编码

分块编码把报文分割为若干个大小已知的块。块之间是紧挨着发送的，这样就不需要在发送之前知道整个报文的大小了。

**要注意的是，分块编码是一种传输编码，因此是报文的属性，而不是主体的属性。本章前面部分讨论过的多部分编码，就是主体的属性，它和分块编码是完全独立的。** 

使用分块传输编码，数据分解为一系列数据块，并以一个或者多个传输，这样服务器可以发送数据，而不先知道数据的大小，对于数据大小未知的情况下适用

当请求头或响应头部中含有Transfer-Encoding: chunked时，Content-Length头将会被忽略，不起作用；同时每个块的开始处以16进制数值表示当前块的数据大小，后是\r\n；然后是当前chunk的数据内容，后是\r\n；终止块是一个常规块，但长度为零。当读取到chunk 的数据大小是0时，意味着请求或响应数据已经分块传输完毕。

 ~~~http
HTTP/1.1 206 OK[CRLF]
Content-Type: text/plain[CRLF]
Transfer-Encoding: chunked[CRLF]
[CRLF]
7[CRLF]                            ——> 第一个chunk块，大小为7字节
Mozilla[CRLF]                      ——> 第一个chunk块内容
9[CRLF]                            ——> 第二个chunk块，大小为9字节
Developer[CRLF]                    ——> 第二个chunk块内容
7[CRLF]                            ——> 第三个chunk块，大小为7字节
Network[CRLF]                      ——> 第三个chunk块内容
0[CRLF]                            ——> 标记性终止块，大小为0字节
[CRLF]
 ~~~

适用场景:

- 未知大小: 希望在知道大小之前先开始传输，用特殊的脚注表明数据传输结束
- 安全性：打乱顺序

分块与持久连接：

- 当是持久连接时，不需要知道Content-length。只需要读到服务器关闭TCP连接为止
- 持久连接时，服务器在写主体时，需要知道Content-length，并在首部中发送，如果服务器想要动态创建内容，就无法知道内容长度。这时候可以使用分块传输。分块编码为这种困难提供了解决方案，只要允许服务器把主体逐块发送，说明每块的大小就可以了。因为主体是动态创建的，服务器可以缓冲它的一部分，发送其大
  小和相应的块，然后在主体发送完之前重复这个过程。服务器可以用大小为0 的块作为主体结束的信号，这样就可以继续保持连接，为下一个响应做准备。

客户端也可以发送分块的数据给服务器。因为客户端事先不知道服务器是否接受分
块编码（这是因为服务器不会在给客户端的响应中发送TE 首部），所以客户端必须
做好服务器用411 Length Required（需要Content-Length 首部）响应来拒绝分块
请求的准备。



如果客户端TE首部接受拖挂的话，就可以在分块的报文最后添加拖挂，。Content-MD5 首部就是一个可以在拖挂中发送的首部，因为在文档生成之前，很难算出它的MD5（Trailer：Content-MD5）

需要注意的是不要把传输编码发送到非HTTP/1.1程序，如果服务器无法理解经过传输编码的报文，应当用501 Unimplemented 状态码来回复